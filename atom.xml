<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>打工人的博客</title>
  
  
  <link href="https://michael-d-666.github.io/atom.xml" rel="self"/>
  
  <link href="https://michael-d-666.github.io/"/>
  <updated>2021-12-06T13:29:42.058Z</updated>
  <id>https://michael-d-666.github.io/</id>
  
  <author>
    <name>早八打工人</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NuistOJ</title>
    <link href="https://michael-d-666.github.io/2021/12/06/NuistOJ/"/>
    <id>https://michael-d-666.github.io/2021/12/06/NuistOJ/</id>
    <published>2021-12-06T09:17:31.000Z</published>
    <updated>2021-12-06T13:29:42.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="P1029-滑雪"><a href="#P1029-滑雪" class="headerlink" title="P1029 滑雪"></a>P1029 滑雪</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">小明喜欢滑雪，为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。小明想知道在一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子:</span><br><span class="line">1  2  3  4 5</span><br><span class="line">16 17 18 19 6</span><br><span class="line">15 24 25 20 7</span><br><span class="line">14 23 22 21 8</span><br><span class="line">13 12 11 10 9</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输入描述：<br>输入的第一行表示区域的行数 R 和列数 C(1≤<em>R</em>,<em>C</em>≤100). 下面是 <em>R</em> 行，每行有 <em>C</em> 个整数，代表高度 <em>h</em> , 0≤<em>h</em>≤10000.<br>5 5<br>1 2 3 4 5<br>16 17 18 19 6<br>15 24 25 20 7<br>14 23 22 21 8<br>13 12 11 10 9</p><p>输出：<br>输出最长区域的长度.<br>25</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>小明假如在某一个点，他可以朝四个方向中的任意一个方向滑行，所以肯定要有一个循环次数为4的for循环来遍历四个方向。<br>这里就用两个长度为4的数组xi、yi来简化四个方向。<br>ma_p中存的是原地图,vis用来保存当前点的最长所求路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;<span class="number">4</span>;p++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x+xi[p]&gt;r<span class="number">-1</span>||x+xi[p]&lt;<span class="number">0</span>||y+yi[p]&lt;<span class="number">0</span>||y+yi[i]&gt;c<span class="number">-1</span>)&#123; <span class="comment">//不能滑到地图外面去</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ma_p[x][y]&gt;ma_p[x+xi[p]][y+yi[p]])&#123;<span class="comment">//找到了比当前高度低的点</span></span><br><span class="line">            vis[x][y]=<span class="built_in">max</span>(vis[x][y],<span class="built_in">dp</span>(x+xi[p],y+yi[p])+<span class="number">1</span>);<span class="comment">//不知道当前点的最长路径和下一个点的最长路径哪一个长，下一个点要加上到当前点的距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    k=<span class="built_in">max</span>(k,vis[x][y]);<span class="comment">//要求出四个方向上的最长路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>技巧：可以加一个记忆化操作来减少计算时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(visited[x][y]!=<span class="number">1</span>)       <span class="comment">//判断该点是否计算过，实现记忆化过程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> visited[x][y];</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> tu[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> xi[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> yi[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> r,c;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[x][y]!=<span class="number">1</span>) <span class="comment">//记忆化操作</span></span><br><span class="line">        <span class="keyword">return</span> vis[x][y];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;<span class="number">4</span>;p++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x+xi[p]&gt;r<span class="number">-1</span>||x+xi[p]&lt;<span class="number">0</span>||y+yi[p]&gt;c<span class="number">-1</span>||y+yi[p]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tu[x][y]&lt;tu[x+xi[p]][y+yi[p]])<span class="comment">//这里大于或者小于都可以</span></span><br><span class="line">            vis[x][y]=<span class="built_in">max</span>(vis[x][y],<span class="built_in">dp</span>(x+xi[p],y+yi[p])+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        k=<span class="built_in">max</span>(k,vis[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;r&gt;&gt;c)&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++)&#123;</span><br><span class="line">                cin&gt;&gt;tu[i][j];</span><br><span class="line">                vis[i][j]=<span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++)&#123;</span><br><span class="line">                count=<span class="built_in">max</span>(count,<span class="built_in">dp</span>(i,j)); <span class="comment">//dp(i,j)表示从某一个点出发的最长路径，所以count每次都要取最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P1138-前中求后"><a href="#P1138-前中求后" class="headerlink" title="P1138 前中求后"></a>P1138 前中求后</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给出一棵二叉树的中序遍历 (inorder)和前序遍历 (preorder)，求它的后序遍历 (postorder)。</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>套用模板，在后序遍历位置输出字符，就会得到后序遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 二叉树遍历框架 */</span><br><span class="line">void traverse(TreeNode root) &#123;</span><br><span class="line">    // 前序遍历</span><br><span class="line">    traverse(root.left)</span><br><span class="line">    // 中序遍历</span><br><span class="line">    traverse(root.right)</span><br><span class="line">    // 后序遍历</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bianli</span><span class="params">(string inorder,string preorder)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder.<span class="built_in">empty</span>())<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span> root=preorder[<span class="number">0</span>];</span><br><span class="line">    preorder.<span class="built_in">erase</span>(preorder.<span class="built_in">begin</span>());<span class="comment">//获取根节点并删除，相当于inorder.substr(0,k),但实际上不行，因为有可能inorder为0</span></span><br><span class="line">    <span class="keyword">int</span> k=inorder.<span class="built_in">find</span>(root); <span class="comment">//找到根节点的位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    string inorder_left=inorder.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    string inorder_right=inorder.<span class="built_in">substr</span>(k+<span class="number">1</span>);</span><br><span class="line">       </span><br><span class="line">    string preorder_left=preorder.<span class="built_in">substr</span>(<span class="number">0</span>,k);</span><br><span class="line">    string preorder_right=preorder.<span class="built_in">substr</span>(k);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bianli</span>(inorder_left,preorder_left);</span><br><span class="line">    <span class="built_in">bianli</span>(inorder_right,preorder_right);</span><br><span class="line">    cout&lt;&lt;root;<span class="comment">//在后序位置输出</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string inorder;</span><br><span class="line">    string preorder;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;inorder&gt;&gt;preorder)</span><br><span class="line">    <span class="built_in">bianli</span>(inorder,preorder);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P1204-电池寿命"><a href="#P1204-电池寿命" class="headerlink" title="P1204 电池寿命"></a>P1204 电池寿命</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Steven 买了一个模型直升机，这架飞机由两节 5 号电池供电。为了保证能够长时间飞行，他买了很多 5 号电池。这些电池的生产商不同，质量也有差异，因而使用寿命也有所不同。有的能使用 5 个小时，有的可能就只能使用 3 个小时。显然如果他只有两个电池，一个能用 5 小时一个能用 3 小时，那么他只能进行 3 个小时的驾驶飞行，有一个电池剩下的电量无法使用。但是如果他有更多的电池，就可以更加充分地利用它们。比如他有三个电池分别能用 3、3、5 小时，他可以先使用两节能用 3 个小时的电池，使用半个小时后再把其中一个换成能使用 5 个小时的电池，两个半小时后再把剩下的一节电池换成刚才换下的电池（那个电池还能用 2.5 个小时），这样总共就可以使用 5.5 个小时，没有一点浪费。</span><br><span class="line"></span><br><span class="line">现在已知电池的数量和电池能够使用的时间，请你帮 Steven 找一种方案使得使用时间尽可能的长。</span><br></pre></td></tr></table></figure><p>输入描述<br>输入包含多组数据。每组数据包括两行，第一行是一个整数 N (2 &lt;= N &lt;= 1000)，表示电池的数目，接下来一行 (请 Java 和 python 注意，不止一行) 是 N 个正整数表示电池能使用的时间<br>2<br>3 5</p><p>3<br>3 3 5</p><p>输出描述<br>3.0<br>5.0</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>先攘外再安内</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sum-maxV&gt;maxV)  <span class="comment">//如果其他电池比得过最大的</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%.1f\n&quot;</span>,maxV+(sum-maxV-maxV)*<span class="number">1.0</span>/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span><span class="comment">//如果其他所有电池加起来都比不过最大的</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%.1f\n&quot;</span>,(sum-maxV)*<span class="number">1.0</span>);<span class="comment">//注意要乘以1.0</span></span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxV=<span class="number">-1111</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">            maxV=<span class="built_in">max</span>(maxV,a[i]);</span><br><span class="line">            sum+=a[i];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum-maxV&gt;maxV)</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%.1f\n&quot;</span>,maxV+(sum-maxV-maxV)*<span class="number">1.0</span>/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.1f\n&quot;</span>,(sum-maxV)*<span class="number">1.0</span>);<span class="comment">//注意要乘以1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;P1029-滑雪&quot;&gt;&lt;a href=&quot;#P1029-滑雪&quot; class=&quot;headerlink&quot; title=&quot;P1029 滑雪&quot;&gt;&lt;/a&gt;P1029 滑雪&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    
    <category term="OJ/ACM" scheme="https://michael-d-666.github.io/tags/OJ-ACM/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言知识整理</title>
    <link href="https://michael-d-666.github.io/2021/12/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://michael-d-666.github.io/2021/12/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2021-12-06T02:10:57.000Z</published>
    <updated>2021-12-06T03:29:03.341Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li><p>AX的寄存器值若是0304，则AH是03，AL是04<br><img src="https://s2.loli.net/2021/12/06/ETUWopzN6V5IrhJ.png" alt="image-20211206101919971"></p></li><li><p>给某一地址存入字形数据<br>（在文本文件中写的时候，mov word ptr [bx],0405h和mov [bx],0405h两者等价，但在dos中无法mov [bx],0405）<br><img src="https://s2.loli.net/2021/12/06/BDkXSfFOb5TQmyu.png" alt="image-20211206102230606"></p></li><li><p>不能直接通过寄存器寻址来赋值立即数，要通过寄存器当中转<br><img src="https://s2.loli.net/2021/12/06/3NdjWp5SF8ugI1c.png" alt="image-20211206102654027"></p></li><li><p>在8086之中，只有四个寄存器可以在【】中进行内存单元的寻址：BX，BP，SI，DI。若中括号中出现AX，则会报错。并且这四个中间，BX和SI一起出现、BX和DI可一起出现，BP和SI可以一起出现，BP和DI一起出现。其余组合不能出现。<br><a href="https://blog.csdn.net/qq_42282258/article/details/82795286">中括号，寻址寄存器的使用</a></p></li><li><p>80*25彩色模式</p><p>DOS窗口一行可以显示80个字符，一行160个字节。总共有25行，这被当作一页。每个字符两个字节，总共4000B，近似4KB。</p><p>显存总共32KB，从B8000H—BFFFFH。</p><p>显示器默认显示第0页。</p><p>每个字符占两个字节，高位字节表示颜色属性，地位字节表示字符的ASCII码。</p><p>颜色属性总共有8位</p><p><img src="https://s2.loli.net/2021/12/06/f7OjAnSswTyB3ie.png" alt="image-20211206110912459"></p></li><li><p>内中断 int 21h</p><table><thead><tr><th>AH</th><th>功能</th><th>调用参数</th></tr></thead><tbody><tr><td>02</td><td>显示输出</td><td>DL=输出字符</td></tr><tr><td>4C</td><td>带返回码结束</td><td>AL=返回码</td></tr></tbody></table><p><a href="https://www.cnblogs.com/ynwlgh/archive/2011/12/12/2285017.html">INT 21H 指令说明</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;AX的寄存器值若是0304，则AH是03，AL是04&lt;br&gt;&lt;img src=&quot;https://s2.lo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://michael-d-666.github.io/2021/12/05/hello-world/"/>
    <id>https://michael-d-666.github.io/2021/12/05/hello-world/</id>
    <published>2021-12-05T14:59:02.219Z</published>
    <updated>2021-12-06T08:52:44.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第二次踩坑"><a href="#第二次踩坑" class="headerlink" title="第二次踩坑"></a>第二次踩坑</h3><p>网站的背景想要改成渐变的颜色，可是怎么该也仍然是纯白的背景，而且网站打开检查发现也是可以接收的。在本地浏览是可以成功看到的。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><img src="https://s2.loli.net/2021/12/06/QWTzrOiGNvSkyeb.png" alt="image-20211206165112039"></p><p>在hexo的config配置文件下将url修改成网页地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第二次踩坑&quot;&gt;&lt;a href=&quot;#第二次踩坑&quot; class=&quot;headerlink&quot; title=&quot;第二次踩坑&quot;&gt;&lt;/a&gt;第二次踩坑&lt;/h3&gt;&lt;p&gt;网站的背景想要改成渐变的颜色，可是怎么该也仍然是纯白的背景，而且网站打开检查发现也是可以接收的。在本地浏览是可以成功</summary>
      
    
    
    
    
  </entry>
  
</feed>
